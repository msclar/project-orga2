\documentclass[a4paper]{article}

\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=2.5cm]{geometry}
\usepackage[spanish,activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{graphicx} %Para incluir el logo de la UBA
\usepackage{caratula} %Para armar el cuadro de integrantes
\usepackage{multirow} %Para poder poner varias lineas juntas sin divisiones en una tabla
\usepackage[lined,ruled,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{scrextend}
\usepackage{blindtext}
\usepackage{colortbl}
\usepackage{color}


%Cosas para escribir codigo fuente
%Fuente: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}
\usepackage{color}

\setcounter{secnumdepth}{5}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{myorange}{rgb}{1,0.4,0.2}
\definecolor{myblue}{rgb}{0,0,0.65}

%Configuracion para los listings
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\small,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keywordstyle=\color{myblue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{myorange},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\renewcommand{\lstlistingname}{C\'{o}digo}

\lstset{language=C++,caption={Descriptive Caption Text},label=DescriptiveLabel}
\setlength\parindent{0pt}

%\topmargin = -1cm
%\textheight = 24cm 

\begin{document}


\integrante{Sclar, Melanie}{551/12}{melaniesclar@gmail.com}
\integrante{Zylber, Ariel}{530/12}{arielzylber@gmail.com}

\def\Materia{Final de Organizaci\'on del Computador II}
\def\Fecha{Muy pronto}

%----- CARATULA -----%

\thispagestyle{empty}

\begin{center}
	\includegraphics[scale = 0.25]{logo_uba.jpg}
\end{center}

\vspace{5mm}

\begin{center}
	{\textbf{\large UNIVERSIDAD DE BUENOS AIRES}}\\[1.5em]
	{\textbf{\large Departamento de Computaci\'{o}n}}\\[1.5em]
    {\textbf{\large Facultad de Ciencias Exactas y Naturales}}\\
    \vspace{35mm}
    {\LARGE\textbf{\Materia}}\\[1em]    
    \vspace{15mm}
    {\Large \textbf{\Titulo}}\\[1em]
    \vspace{15mm}
    {\textbf{\Large \Fecha}}\\
    \vspace{15mm}
    \textbf{\tablaints}
\end{center}

\newtheorem{teo}{Teorema}[section]
\newtheorem{propo}{Proposici\'{o}n}[section]
\newtheorem{lema}{Lema}[section]
\newtheorem{coro}{Corolario}[section]
\newtheorem{defi}{Definici\'{o}n}[section]

\newpage
\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{plain}

\newpage


\newcommand{\Asig}{\ensuremath{\leftarrow}}
\newcommand{\AndY}{\ensuremath{\wedge}}
\newcommand{\Or}{\ensuremath{\vee}}
\newcommand{\Not}{\ensuremath{\neg}}
\newcommand{\NotEq}{\ensuremath{\neq}}
\newcommand{\MayorIg}{\ensuremath{\geq}}
\newcommand{\tabu}{\hspace*{0.7cm}}
\newcommand{\ctabu}{\hspace*{0.8cm}}
\newcommand{\htabu}{\hspace*{0.35cm}}
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\section{Objetivo del trabajo}

El objetivo del trabajo es resolver la ecuación de Biocalor de Pennes 
utilizando el método de Jacobi para calcular la temperatura en cada 
sección de un tejido a cada instante de tiempo. Esto se enmarca dentro 
de los proyectos del Laboratorio de Sistemas Complejos (DC-UBA), pues 
el LSC aplicará nuestro trabajo para agilizar el cálculo de una sección 
de su modelo para identificar la temperatura y posición óptimas en las 
que aplicar un tratamiento para reducir los tumores cancerígenos. A 
grandes rasgos, los tratamientos ultilizados consiste en colocar dos electrodos (un 
ánodo y un cátodo) en puntos específicos de la piel del paciente 
cercanos al tumor y lograr la destrucción del tejido cancerígeno 
debido a cambios de pH, aumento de permeabilidad irreversible en la 
membrana plasmática o aumento en la absorción del quimioterápico, 
entre otros. Como efecto secundario del tratamiento se produce un 
aumento de temperatura en el tejido. Nosotros desarrollaremos un 
modelo para simular calentamiento del tejido y así poder estudiar 
que consecuencias trae al paciente. Gráficamente,\\

\begin{figure}[!htbp]
  \centering
	\includegraphics[scale = 0.18]{tejido-anotado.png}
  \caption{Representación gráfica del tratamiento para el tumor}
\end{figure}

Además de resolver la ecuación de Pennes, se resolverá la ecuación
de Laplace para calcular el potencial eléctrico del tejido (que es uno de los parámetros
de la ecuación de Pennes). Una explicación detallada de su cálculo se podrá ver más adelante.\\

Como la resolución de estas ecuaciones ocupa una parte no despreciable 
del cómputo de sus algoritmos completos, lo implementamos en C plano y en ASM con SIMD y 
compararemos los tiempos de ejecución obtenidos con cada una (compilando con gcc e icc). Creemos que 
utilizar SIMD podría ser muy provechoso en este problema, ya que muchas 
de las operaciones de matrices que efectuaremos son paralelizables y 
esperamos ver una significante reducción en el tiempo de ejecución del 
algoritmo. Notar que se aprovechará la estructura particular del problema para optimizar al máximo la
resolución: el programa resultante es más complejo pero esto hace que se reduzca la complejidad
temporal del programa en varios órdenes.\\

Como todos los cálculos son con números de punto flotante con doble 
precisión, utilizaremos los registros YMM (cuya longitud es el doble que la de los
registros XMM vistos en la materia) para poder paralelizar el cálculo de 4 números en vez de sólo 2.\\

Cabe destacar que el LSC no tenía implementación alguna de esto que vamos
a resolver, por lo que parte del alcance del trabajo fue dar un programa
en C que resuelva correctamente el problema. La comprobación de que los resultados 
fue no trivial, e incluyó consultas a diversos integrantes del LSC para
realizar un análisis cuantitativo y cualitativo de los resultados. Una explicación del
análisis realizado y sus resultados gráficos se mostrará al final del trabajo.

\newpage
\section{Distribuci\'on de la temperatura: obtención del sistema a resolver}

A continuación partiremos de la ecuación de Biocalor de Pennes y despejaremos
el sistema de ecuaciones a resolver. Cada punto del tejido tiene una 
ecuación que describe la evolución de su temperatura: la mayoría de los puntos
se rigen por las ecuaciones obtenidas en la sección 2.1, mientras que los bordes
tienen sus particularidades que se describen en la sección 2.2. 
Llamamos $bordes$ tanto a los bordes exteriores del recinto
(los bordes de la matriz) como a los puntos donde se aplican los electrodos.
Las ecuaciones nos fueron ya dadas por el LSC, y nosotros únicamente las 
comprobamos, hicimos las correcciones necesarias e implementamos en C y ASM.

\subsection{Temperatura en todo el tejido salvo los bordes}

Partimos de la ecuación de Biocalor de Pennes, 
$$\nabla \cdot (k \nabla T) - w_b C_b \rho_b (T-T_a) + q''' + \sigma |\nabla \varphi|^2 = \rho \ C_\rho \ \frac{\partial T}{\partial t}$$

Donde $\sigma$ es la conductividad eléctrica, $\phi$ es el potencial eléctrico, $k$ es la conductividad térmica, $T_a$ es la temperatura arterial, $w_b$ es la blood perfusion rate, $C_b$ es la capacidad calorífica de la sangre, $\rho_b$ es la densidad de la sangre, $q'''$ es la generación de calor metabólico, $\rho$ es la densidad del tejido y $C_\rho$ es la capacidad calorífica del tejido.\\

Para nuestro modelo, hay varias constantes que suponemos conocidas, en los siguientes valores:

$C_\rho= 3680$, $\rho= 1039$, $q'''= 10437$, $C_b= 3840$, $\rho_b= 1060$, $w_b=7.15 \ 10^{-3}$, $T_a = 310.15^\circ K$ \\

$k$, $\sigma$ y $\varphi$ son campos escalares variables. Sin embargo, a la hora de realizar los cálculos tomaremos los siguientes valores para las funciones,
como fue indicado por Emmanuel Luján. 

$k(x,y)=0.565$ \\
$\sigma(x,y)=0.75$ \\

Para calcular $\varphi$ supondremos dado un ánodo en la posición $(x_a, y_a)$ con potencial eléctrico 
constante $q_a$ y un cátodo en la posición $(x_c, y_c)$ con potencial eléctrico 
constante $q_c$. Luego obtenemos como se extiende la $\varphi$ a todo el recinto 
resolviendo la ecuación de Laplace dados los puntos del ánodo y cátodo fijos y 
condición de borde de flujo cero. Para más detalles sobre como calcular esto ver apéndice B.
\textbf{La resolución de la ecuación de Laplace también formará parte de nuestro trabajo de implementación.}\\

Notar que en estos valores particulares los campos son constantes en el tiempo pero al realizar la discretización del problema no lo supondremos constante que sino lo haremos en la versión general donde sus valores podrían depender del tiempo.

Entonces, los únicos valores desconocidos para nosotros son los $T_n(i,j)$, es decir, el valor de la temperatura en el tiempo $n$ (ya discretizado) en cada lugar del espacio $(i,j)$.
Utilizaremos las discretizaciones tal y como nos fueron indicadas: el término temporal por diferencias adelantadas, los términos espaciales por diferencias centradas. \\

A continuación calcularemos el término $\nabla \cdot (k \nabla T)$:
\begin{equation} \label{eq:nablaT}
\begin{split}
\nabla \cdot (k \nabla T) & = \nabla \cdot k \bigg(\frac{\partial T}{\partial x}, \frac{\partial T}{\partial y}\bigg) \\
& = \frac{\partial}{\partial x} \bigg(k \frac{\partial T}{\partial x}\bigg) + \frac{\partial}{\partial y} \bigg(k \frac{\partial T}{\partial y}\bigg) \\
& = \frac{\partial k}{\partial x} \cdot \frac{\partial T}{\partial x} + k \cdot \frac{\partial^2 T}{\partial x^2} + \frac{\partial k}{\partial y} \cdot \frac{\partial T}{\partial y} + k \cdot \frac{\partial^2 T}{\partial y^2} \\
 & = \frac{\partial k}{\partial x} \cdot \frac{\partial T}{\partial x} + \frac{\partial k}{\partial y} \cdot \frac{\partial T}{\partial y} + k \cdot \frac{\partial^2 T}{\partial x^2} + k \cdot \frac{\partial^2 T}{\partial y^2}
\end{split}
\end{equation}

Notar que si $k$ es constante, $\frac{\partial k}{\partial x} = \frac{\partial k}{\partial y} = \frac{\partial k}{\partial t} = 0$ y por lo tanto, obtenemos $\nabla \cdot (k \nabla T) = k \cdot \frac{\partial^2 T}{\partial x^2} + k \cdot \frac{\partial^2 T}{\partial y^2} + k \cdot \frac{\partial^2 T}{\partial t^2}$ \\
Sin embargo, a priori no sabemos que nuestro modelo de aplicación será con $k$ constante así que deberemos calcular sus derivadas. Mostramos cómo se calculan todas las derivadas respecto de $T$ con sus discretizaciones, y para $k$ será análogo.

\begin{equation*}
\begin{split}
\frac{\partial T}{\partial x} & \approx \frac{T_{n+1}(i+1,j) - T_{n+1}(i-1,j)}{\Delta x_i + \Delta x_{i+1}} \\
\frac{\partial T}{\partial y} & \approx \frac{T_{n+1}(i,j+1) - T_{n+1}(i,j-1)}{\Delta y_j + \Delta y_{j+1}} \\
\frac{\partial^2 T}{\partial x^2} & \approx \frac{2 T_{n+1}(i+1,j)}{\Delta x_i (\Delta x_i + \Delta x_{i-1})} - \frac{2 T_{n+1}(i,j)}{\Delta x_i \Delta x_{i-1}} + \frac{2 T_{n+1}(i-1,j)}{\Delta x_{i-1} (\Delta x_i + \Delta x_{i-1})} \\
\frac{\partial^2 T}{\partial y^2} & \approx \frac{2 T_{n+1}(i,j+1)}{\Delta y_j (\Delta y_j + \Delta y_{j-1})} - \frac{2 T_{n+1}(i,j)}{\Delta y_j \Delta y_{j-1}} + \frac{2 T_{n+1}(i,j-1)}{\Delta y_{j-1} (\Delta y_j + \Delta y_{j-1})} \\
\frac{\partial T}{\partial t} & \approx \frac{T_{n+1}(i,j) - T_n(i,j)}{\Delta t_n}
\end{split}
\end{equation*}

Como podemos asumir que $\Delta x_i = \Delta x_j = \Delta x$ y $\Delta y_i = \Delta y_j = \Delta y$ para todo $i$, $j$, las ecuaciones quedan así:
\begin{equation} \label{eq:derivadas}
\begin{split}
\frac{\partial T}{\partial x} & \approx \frac{T_{n+1}(i+1,j) - T_{n+1}(i-1,j)}{2\Delta x}  \\
\frac{\partial T}{\partial y} & \approx \frac{T_{n+1}(i,j+1) - T_{n+1}(i,j-1)}{2\Delta y} \\
\frac{\partial^2 T}{\partial x^2} & \approx \frac{T_{n+1}(i+1,j)}{(\Delta x)^2} - \frac{2 T_{n+1}(i,j)}{(\Delta x)^2} + \frac{T_{n+1}(i-1,j)}{(\Delta x)^2} \\
\frac{\partial^2 T}{\partial y^2} & \approx \frac{T_{n+1}(i,j+1)}{(\Delta y)^2} - \frac{2 T_{n+1}(i,j)}{(\Delta y)^2} + \frac{T_{n+1}(i,j-1)}{(\Delta y)^2} \\
\frac{\partial T}{\partial t} & \approx \frac{T_{n+1}(i,j) - T_n(i,j)}{\Delta t}
\end{split}
\end{equation}

Aplicando todo esto a la ecuación del Biocalor de Pennes, despejamos los coeficientes de $T_n$ en función de los de $T_{n+1}$, para obtener un sistema de ecuaciones a resolver con Jacobi. Tomemos la ecuación del Biocalor de Pennes:
$$\nabla \cdot (k \nabla T) - w_b C_b \rho_b (T-T_a) + q''' + \sigma |\nabla \varphi|^2 = \rho \ C_\rho \ \frac{\partial T}{\partial t}$$

Reemplazando con lo obtenido en (\ref{eq:nablaT}),
$$ \frac{\partial k}{\partial x} \cdot \frac{\partial T}{\partial x} + \frac{\partial k}{\partial y} \cdot \frac{\partial T}{\partial y} + k \cdot \frac{\partial^2 T}{\partial x^2} + k \cdot \frac{\partial^2 T}{\partial y^2} - w_b C_b \rho_b (T-T_a) + q''' + \sigma |\nabla \varphi|^2 = \rho \ C_\rho \ \frac{\partial T}{\partial t}$$

Luego, aproximamos las derivadas como definimos en (\ref{eq:derivadas}):\\
\begin{equation*}
\begin{aligned}
\rho \ C_\rho \ \frac{T_{n+1}(i,j) - T_n(i,j)}{\Delta t} &= \frac{\partial k}{\partial x} \cdot \frac{T_{n+1}(i+1,j) - T_{n+1}(i-1,j)}{2\Delta x} \\ & \ \ \ \ \ \ \  + \frac{\partial k}{\partial y} \cdot \frac{T_{n+1}(i,j+1) - T_{n+1}(i,j-1)}{2\Delta y} \\ & \ \ \ \ \ \ \ + k \cdot \bigg(\frac{T_{n+1}(i+1,j)}{(\Delta x)^2} - \frac{2 T_{n+1}(i,j)}{(\Delta x)^2} + \frac{T_{n+1}(i-1,j)}{(\Delta x)^2}\bigg) \\ & \ \ \ \ \ \ \  + k \cdot \bigg(\frac{T_{n+1}(i,j+1)}{(\Delta y)^2} - \frac{2 T_{n+1}(i,j)}{(\Delta y)^2} + \frac{T_{n+1}(i,j-1)}{(\Delta y)^2}\bigg) \\ & \ \ \ \ \ \ \  -  w_b C_b \rho_b (T_{n+1}(i,j)-T_a) + q''' + \sigma |\nabla \varphi|^2\\
\end{aligned}
\end{equation*}

\bigskip
Ahora sí, despejemos $T_n$ en función de los de $T_{n+1}$. Para abreviar, sea $TInd = w_b C_b \rho_b T_a + q''' + \sigma |\nabla \varphi|^2$. \\

\begin{equation*}
\begin{aligned}
- T_n(i,j) \frac{\rho \ C_\rho}{\Delta t} - TInd(i,j) &= T_{n+1}(i+1,j) \cdot \bigg(\frac{\partial k}{\partial x} \cdot \frac{1}{2\Delta x} +  k \cdot\frac{1}{(\Delta x)^2}\bigg) \\ & \ \ \ \ \ \ \ + T_{n+1}(i-1,j) \cdot \bigg(-\frac{\partial k}{\partial x} \cdot \frac{1}{2\Delta x} + k \cdot\frac{1}{(\Delta x)^2}\bigg) \\ & \ \ \ \ \ \ \ + T_{n+1}(i,j) \cdot \bigg(-\frac{2k}{(\Delta x)^2} -\frac{2k}{(\Delta y)^2} - w_b C_b \rho_b - \rho \ C_\rho \ \frac{1}{\Delta t}\bigg) \\ & \ \ \ \ \ \ \ + T_{n+1}(i,j+1) \cdot \bigg(\frac{\partial k}{\partial y} \cdot \frac{1}{2\Delta y} + k \cdot\frac{1}{(\Delta y)^2}\bigg) \\ & \ \ \ \ \ \ \  + T_{n+1}(i,j-1) \cdot \bigg(-\frac{\partial k}{\partial y} \cdot \frac{1}{2\Delta y} + k \cdot\frac{1}{(\Delta y)^2}\bigg)
\end{aligned}
\end{equation*}

Con estas ecuaciones nos quedará un sistema a resolver, pero antes de plantearlo debemos explicitar cuáles serán las condiciones de borde en este problema, ya que las ecuaciones antes dichas no valen en el borde exterior ni alrededor del ánodo y cátodo.

\subsection{Temperatura en los bordes}

\subsubsection{Temperatura en bordes exteriores}
La condición de borde del sistema es de flujo cero, es decir $q \cdot \hat{n} = 0$ donde $\hat{n}$ es el vector unitario normal al borde del recinto. Esto quiere decir que $-K \nabla T \cdot \hat{n} = 0$, dividiendo por $-K$ queda $\nabla T \cdot \hat{n} = 0$. Esto se interpreta como que en el borde la derivada en la dirección hacia adentro es nula. Al discretizar, esto se traduce en que la diferencia entre la temperatura en un punto del borde y su inmediato vecino interno es nula, es decir que son iguales. Más formalmente, asumiremos que:
\begin{equation*}
\begin{aligned}
T_{n+1}(0,j) & = T_{n+1}(1,j) \\ 
T_{n+1}(i,0) & = T_{n+1}(i,1) \\
T_{n+1}(i,max_j) & = T_{n+1}(i,max_j-1) \\ 
T_{n+1}(max_i,j) & = T_{n+1}(max_i-1,j)
\end{aligned}
\end{equation*}

\subsubsection{Temperatura en los puntos del tejido donde se aplican los electrodos}
Además, en el borde de los electrodos (ánodo y cátodo) el cálculo de la temperatura es diferente. Los detalles de su cálculo se pueden ver en el Apéndice A. Siendo $(i,j)$ la aproximación del borde del electrodo,

$$T_{n+1}(i,j) = \frac{r}{4(r-1)} \cdot \big( T_{n+1}(i+1,j) + T_{n+1}(i,j+1) + T_{n+1}(i-1,j) + T_{n+1}(i,j-1)\big) - \frac{T_{aire}}{r-1}$$

Donde $r = \frac{k}{\Delta x \cdot h}$, $h = 10 \frac{W}{m^2 K}$ y $T_{aire} = 296 ^\circ K$.\\ 

En nuestro trabajo, las posiciones de los electrodos serán parte del input del programa.

\subsection{Planteo del sistema y resolución}

Habiendo hallado todas las ecuaciones que relacionan $T_n$ con $T_{n+1}$, 
podemos escribir un sistema a resolver de la forma $$A \cdot T_{n+1} = -\frac{\rho \cdot C_\rho}{\Delta t} \cdot T_n - TInd$$ y 
despejar $T_{n+1}$ utilizando Jacobi. Consideramos a $A$ como la matriz 
cuadrada de lado $max_i \cdot max_j$ donde cada fila (y cada columna) corresponde a 
una posición $(i, j)$ de la discretización de modo que en la fila de la 
posición $(i, j)$ tendremos los coeficientes de la ecuación correspondiente 
a $T_n(i,j)$ para cada posición de la grilla. Notemos que luego de hallar $T_n$, 
la única incógnita del sistema es en efecto $T_{n+1}$ y en efecto se puede aplicar Jacobi usualmente.\\

Notemos que la matriz $A$ es esparsa, pues en cada fila los coeficientes 
que podrían ser no nulos corresponden a las posiciones del punto en 
cuestión y sus vecinos. Con esto conseguiremos reducir mucho el tiempo 
de cómputo en todas las implementaciones. Esto también implicó un crecimiento
en la complejidad del código a paralelizar, pues ya no es una simple resolución
de sistema de ecuaciones sino que hay que tener sumo cuidado en respetar
los índices indicados como no nulos. \\

Gráficamente, si $A$ fuera una matriz de $6x6$ los únicos lugares que pueden
ser no nulos son los que se muestran en gris en la imagen. Para la fila 
correspondiente a $(i,j)$, los únicos elementos no nulos pueden ser $(i, j-1)$, 
$(i,j+1)$ (que se verán a la izquierda y a la derecha de $(i,j)$ respectivamente), 
$(i-1, j)$ e $(i+1,j)$ (que al estar una fila arriba o abajo de $(i,j)$, 
en el gráfico se verán $max_j = 6$ lugares para la izquierda o para la derecha de él). 

\begin{table}[!htbp]
\centering
\label{matriz_a}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \cellcolor{mygray} & \cellcolor{mygray} & & & & & \cellcolor{mygray} & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline 
 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & \\ \hline
\end{tabular}
\caption{Representación de $A$ para una matriz de $6x6$. En gris se ven las casillas donde es posible que haya un elemento no nulo. Esta representación ignora los bordes (están en blanco): notar que las filas del medio que discontinúan el patrón diagonal corresponden a los bordes verticales ($(i,0)$ o $(i,max_j)$ $\forall i$) y las del principio y final corresponden a ($(0,j)$ o $(max_i,j)$ $\forall j$). }
\end{table}

Como los bordes se rigen por ecuaciones distintas al resto del tejido, comentamos a continuación
cómo las tratamos, teniendo como objetivo optimizar el tiempo de cómputo total:
\begin{itemize}
\item Las ecuaciones de los bordes exteriores sólo
relacionan $T_{n+1}$ en distintos $(i,j)$. La mejor forma de implementar esta
restricción que encontramos fue no incluir los bordes exteriores en el sistema $A$, y una vez
resuelto aplicar las condiciones de borde.
\item Los puntos donde se aplican los electrodos también tienen una 
fórmula diferente al de la mayoría de los puntos. Para evitar incluir 
condicionales se resolvieron esos puntos como si valiera la fóŕmula general
y luego se sobreescribieron los valores por los nuevos.
\end{itemize}

\newpage

\section{Optimizaciones realizadas}

\subsection{Optimizaciones previas a SIMD}

Como vimos en \ref{matriz_a}, cada fila contiene a lo sumo 5 elementos no 
nulos. Es un desperdicio tanto espacial como temporal guardar esos elementos en memoria y analizarlos.
Es por eso que decidimos representar a $A$ como una matriz de 5 filas y $max_i \times max_j$ columnas, 
en la que cada fila guarda uno de los cinco elementos no nulos. Esto será muy útil a la hora de paralelizar
el procesamiento con SIMD, como veremos más adelante. \\
Nuestra convención es la siguiente: 

\begin{table}[!htbp]
\centering
\label{cincovecinos}
\begin{tabular}{l|l|l}
\cline{2-2}
                       & fila 0 &                       \\ \hline
\multicolumn{1}{|l|}{fila 1} & fila 4 & \multicolumn{1}{l|}{fila 3} \\ \hline
                       & fila 2 &                       \\ \cline{2-2}
\end{tabular}
\caption{Representación esquemática de los cinco elementos no nulos, y a qué fila corresponden.}
\end{table}

De esta forma, no guardamos los ceros y tampoco los tendremos en cuenta a la hora de procesar la 
matriz. Esto resulta en un programa mucho más eficiente pero más complejo en su lógica.

\subsection{Optimizaciones con SIMD} 

Primeramente, notemos que nuestra implementación trabaja con números de punto flotante de doble
precisión, que son de 64 bits cada uno. Esta precisión fue requerida por el LSC, para el que no
era suficiente utilizar precisión simple por la exactitud necesaria dado el contexto de utilización.
Con esta restricción, los registros XMM sólo permitirían paralelizar el cómputo de dos elementos por vez,
ya que tienen 128 bits. Es por eso que decidimos utilizar registros YMM a lo largo de todo el trabajo.
Como los registros YMM tienen 256 bits, permiten el cálculo de 4 double-precision floating point numbers
a la vez (64 bits $\times$ 4 $=$ 256 bits).\\
Notar que esto implica que a lo sumo podremos mejorar el tiempo de ejecución de nuestro programa en 4 veces
con el cálculo paralelizado. Seguramente esta cota superior no llegue a cumplirse, pues no todo el programa
es paralelizable.\\

Una observación clave es que a lo largo de todo el trabajo los cálculos importantes a realizar son de la
forma $a_0 \cdot T_{n+1}(i-1,j) + a_1 \cdot T_{n+1}(i,j-1) + a_2 \cdot T_{n+1}(i+1,j) + a_3 \cdot T_{n+1}(i,j+1) + a_4 \cdot T_{n+1}(i,j)$. Esto ocurre en:

\begin{itemize}
\item Cálculo del próximo paso del método iterativo de Jacobi.
\item Cálculo del próximo paso del método iterativo de Laplace.
\item Cálculo del error de Jacobi.
\item Cálculo del término independiente ($TInd$).
\item Creación de la matriz A.
\end{itemize}

%%% SE HACEN ASI

También hay cálculos paralelizables que no son de la forma anteriormente mencionada. Los mismos se incluyeron en el trabajo:

\begin{itemize}
\item Actualización de la matriz B en cada paso del Jacobi.
\item Cálculo de la norma de un vector.
\item Cálculo de la distancia entre dos vectores (utilizado para calcular el error de Laplace).
\item Llenar una matriz con una constante (muy utilizado para inicializar las matrices en cero).
\end{itemize} 

A propósito se excluyó de la paralelización la lectura del input pues depende 
fuertemente de la función deseada por el usuario. Actualmente corremos el programa
con las funciones como fueron pasadas por el LSC a modo de ejemplo, pero ellos utilizarán
nuestro programa con diversas entradas.



\section{Experimentos}

En esta sección compararemos la performance temporal de nuestro programa con y sin optimizaciones
SIMD. Adicionalmente, lo compararemos con la versión sin ninguna optimización previa hecha en C,
para demostrar que las optimizaciones previas también fueron de vital importancia: una implementación
en ASM de esta idea hubiera sido inútil, pues el algoritmo inicial será mucho más lenta. \\

\newpage
\section{Apéndice A: cálculo de temperatura en los electrodos}

Vamos a calcularlo para la pared vertical derecha de cada electrodo, los otros cálculos son análogos. El electrodo tiene 4 \textit{paredes}, pues al discretizar el tejido en una grilla el punto donde se apoya el electrodo quedará dentro de una de las casillas de la grilla.

Siendo $k$ la función definida anteriormente, sea $h = 10 \frac{W}{m^2 K}$ y $T_{aire} = 296 ^\circ K$

\begin{equation*}
\begin{aligned}
-k \frac{\partial T}{\partial x} & = h (T_{n+1}(i,j) -  T_{aire}) \\
-k \ \frac{T_{n+1}(i+1,j) - T_{n+1}(i,j)}{\Delta x} & \approx h (T_{n+1}(i,j) -  T_{aire}) \\
\frac{k}{\Delta x \cdot h} \cdot (T_{n+1}(i,j) - T_{n+1}(i+1,j)) & \approx T_{n+1}(i,j) -  T_{aire}
\end{aligned}
\end{equation*}

Utilizando el renombre $r = \frac{k}{\Delta x \cdot h}$, nos queda:

\begin{equation*}
\begin{aligned}
r \cdot (T_{n+1}(i,j) - T_{n+1}(i+1,j)) & \approx T_{n+1}(i,j) - T_{aire} \\
r \cdot T_{n+1}(i,j) - r \cdot T_{n+1}(i+1,j) & \approx T_{n+1}(i,j) - T_{aire} \\
r \cdot T_{n+1}(i,j) - T_{n+1}(i,j) & \approx r \cdot T_{n+1}(i+1,j) - T_{aire} \\
(r - 1) \cdot T_{n+1}(i,j) & \approx r \cdot T_{n+1}(i+1,j) - T_{aire} \\
T_{n+1}(i,j) & \approx \frac{r \cdot T_{n+1}(i+1,j) - T_{aire}}{r-1}
\end{aligned}
\end{equation*}

Esto mismo se puede calcular para las otras tres paredes del electrodo. En resumen, los cuatro cálculos darán como resultado lo siguiente:

\begin{equation*} \label{eq:paredes}
\begin{aligned}
T_{n+1}(i,j) & \approx \frac{r \cdot T_{n+1}(i+1,j) - T_{aire}}{r-1} \\
T_{n+1}(i,j) & \approx \frac{r \cdot T_{n+1}(i-1,j) - T_{aire}}{r-1} \\
T_{n+1}(i,j) & \approx \frac{r \cdot T_{n+1}(i,j+1) - T_{aire}}{r-1} \\
T_{n+1}(i,j) & \approx \frac{r \cdot T_{n+1}(i,j-1) - T_{aire}}{r-1}
\end{aligned}
\end{equation*}

Finalmente, aproximamos el valor de la temperatura de la casilla donde se coloca el electrodo como el promedio de la temperatura en sus cuadro bordes. Sumando las cuatro ecuaciones de (\ref{eq:paredes}):

\begin{equation*}
\begin{aligned}
4 \cdot T_{n+1}(i,j) & \approx \frac{r \cdot [T_{n+1}(i+1,j) + T_{n+1}(i-1,j) + T_{n+1}(i,j+1) + T_{n+1}(i,j-1)] - 4 \cdot T_{aire}}{r-1} \\
T_{n+1}(i,j) & \approx \frac{r}{4 \cdot (r-1)} \cdot \big(T_{n+1}(i+1,j) + T_{n+1}(i-1,j) + T_{n+1}(i,j+1) + T_{n+1}(i,j-1)\big) - \frac{T_{aire}}{r-1}
\end{aligned}
\end{equation*}

\newpage
\section{Apéndice B: cálculo del potencial eléctrico}

El potencial eléctrico es un campo escalar definido como la solución de la ecuación de Laplace ($\delta \varphi = 0$) dados dos puntos fijos (ánodo y ćatodo) y condición de borde de flujo cero.\\
La discretización de la ecuación $\delta \varphi = 0$ es conocida y corresponde a que una posición es el promedio de sus vecinos. Es decir, $$\varphi(i, j) = \frac{\varphi(i-1, j) + \varphi(i+1, j) + \varphi(i, j-1) + \varphi(i, j+1)}{4}$$
Por otro lado, la condición de borde es la misma que en el caso de la ecuación de calor, por lo que las fórmulas de las discretizaciones en los puntos del borde son análogas y equivalen a:
\begin{equation*}
\begin{aligned}
\varphi(0,j) & = \varphi(1,j) \\ 
\varphi(i,0) & = \varphi(i,1) \\
\varphi(i,max_j) & = \varphi(i,max_j-1) \\ 
\varphi(max_i,j) & = \varphi(max_i-1,j)
\end{aligned}
\end{equation*}
Para obtener una solución aproximada del sistema, iteramos reemplazando el potencial actual de cada posición por el promedio de sus vecinos hasta que estos valores converjan.

\end{document}
